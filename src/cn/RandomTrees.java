package cn;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.List;
import java.util.Random;
import org.apache.commons.io.FileUtils;


import weka.attributeSelection.InfoGainAttributeEval;
import weka.attributeSelection.Ranker;
import weka.classifiers.Evaluation;
import weka.classifiers.trees.J48;
import weka.core.Attribute;
import weka.core.DenseInstance;
import weka.core.Instances;
import weka.core.Utils;
import weka.core.converters.ArffSaver;
import weka.core.converters.ConverterUtils.DataSink;
import weka.core.converters.ConverterUtils.DataSource;
import weka.core.converters.DatabaseLoader;
import weka.filters.supervised.attribute.AddClassification;
import weka.filters.unsupervised.attribute.Add;
import weka.filters.unsupervised.attribute.Remove;
import weka.filters.Filter;
import weka.classifiers.*;



public class RandomTrees {

	/**
	 * generate a instance object
	 *
	 * @return
	 */
	public static Instances gen_Instances(){
		ArrayList<Attribute> attribute = new ArrayList<>();
		attribute.add(new Attribute("ApkName",(ArrayList<String>)null));
		attribute.add(new Attribute("userActionType"));
		attribute.add(new Attribute("senApiDapasaType"));
        attribute.add(new Attribute("senApiPscoutType"));
		attribute.add(new Attribute("permissionType"));
		
		for(int i=1;i<13;i++){
			attribute.add(new Attribute("userAction"+i));
		}

		// first dapasa then pscout
		for(int i=1;i<2607;i++){
			attribute.add(new Attribute("senApi"+i));
		}
		
		for(int i=1;i<122;i++){
			attribute.add(new Attribute("permission"+i));
		}
		
		
		
		//attribute.add(new Attribute("nfubtNum"));
		//attribute.add(new Attribute("nfubtType"));
		
		
		ArrayList<String> isPacked = new ArrayList<>();
		isPacked.add("no");
		isPacked.add("yes");
		
		attribute.add(new Attribute("isMalware",isPacked));
		
		Instances instances=new Instances("SemanticsFeature",attribute,0);
		instances.setClassIndex(instances.numAttributes() - 1);
		
		/*System.out.println(instances.numAttributes());*/
		
		return instances;
	}


	/**
	 * save arff message to path
	 *
	 * @param instances:features of apk
	 * @param path:arff save path
	 */
	public static void gen_Arff(Instances instances, String path) {
		ArffSaver saver=new ArffSaver();
		saver.setInstances(instances);
		
		try {
            saver.setFile(new File(path));
            saver.writeBatch();
        } catch (IOException e) {
            e.printStackTrace();
        }
	}


	/**
	 * input apk samples by instances to train a classifier and use 10 fold
	 *
	 * @param instances
	 * @return
	 * @throws Exception
	 */
	public static String RandomTreeUse(Instances instances){
	    try {
            instances.setClassIndex(instances.numAttributes()-1);

            // set option for weka
            String[] option = new String[4];
            option[0] = "-R";
            option[1] = "1";

            // remove some attributes which are not needed for training of apk
            Remove rm = new Remove();
            rm.setAttributeIndices("1");
            rm.setInputFormat(instances);
            Instances filterdInstances=Filter.useFilter(instances, rm);

            // random samples by random numbers
            long seed = 12341;
            Instances randomInstances = new Instances(filterdInstances);
            randomInstances.randomize(new Random(seed));

            // train a classifier of randomForest
            String className = "weka.classifiers.trees.RandomForest";
            String[] options = new String[2];
            options[0] = "-I";
            options[1] = "100";
            Classifier cf = (Classifier)Utils.forName(Classifier.class, className, options);


		/*AttributeSelection select=new AttributeSelection();
		CfsSubsetEval eval=new CfsSubsetEval();//评估子集权重
		GreedyStepwise search=new GreedyStepwise();//贪心算法搜索子集
		search.setSearchBackwards(true);
		select.setEvaluator(eval);
		select.setSearch(search);
		select.setInputFormat(testInstances);

		Instances newInstances=Filter.useFilter(testInstances, select);
		System.out.println("被处理过的子集"+newInstances);
		*/
            if(randomInstances.classAttribute().isNominal())
                randomInstances.stratify(10);
            Evaluation evaluation=new Evaluation(randomInstances);
            Instances predict=null;

            // 10 fold test
            for (int i=0;i<10;i++) {
                Instances train = randomInstances.trainCV(10, i);
                Instances test = randomInstances.testCV(10, i);
                Classifier cfs = AbstractClassifier.makeCopy(cf);
                cfs.buildClassifier(train);
                evaluation.evaluateModel(cfs, test);
            }

            /*System.out.println(evaluation.toSummaryString());*/
            String result=evaluation.toSummaryString();
            return result;
        } catch (Exception e) {
	        e.printStackTrace();
        }
     	return null;
		
	}

	/*
	获取训练样本训练好的随机森林分类器
	 */
	public Classifier getRandomTreesClf(Instances instances)throws Exception{
		instances.setClassIndex(instances.numAttributes()-1);
		//	System.out.println(testInstances1);
		//	System.out.println("remove过滤后的实例"+testInstances);

		//后面10折交叉验证已经使用了随机数，故我这里就不用再设置随机数
		long seed=12341;
		Instances instances2=new Instances(instances);
		instances2.randomize(new Random(seed));
		//	System.out.println("随机化之前的数据"+instances1);
		//		System.out.println("随机化后的数据"+instances2);

		String className="weka.classifiers.trees.RandomForest";
		String[] options=new String[2];
		options[0]="-I";
		options[1]="100";
		Classifier cf=(Classifier)Utils.forName(Classifier.class, className, options);


		/*AttributeSelection select=new AttributeSelection();
		CfsSubsetEval eval=new CfsSubsetEval();//评估子集权重
		GreedyStepwise search=new GreedyStepwise();//贪心算法搜索子集
		search.setSearchBackwards(true);
		select.setEvaluator(eval);
		select.setSearch(search);
		select.setInputFormat(testInstances);

		Instances newInstances=Filter.useFilter(testInstances, select);
		System.out.println("被处理过的子集"+newInstances);
		*/
		Classifier cfs=null;
		try {
			Instances predict = null;
			cfs= AbstractClassifier.makeCopy(cf);
			cfs.buildClassifier(instances2);
		} catch (Exception e){
			System.out.println("分类器未正常生成，检查RandomTrees.getRandomTreesclf");
			e.printStackTrace();
		}
		return cfs;
	}


    /**
     * forest apk type use data of practice arff
     *
     * @param practiceUrl file data of practice arff
     * @param testInstances test instance of apk which is needed to be forest
     * @return 0 if this apk is benign and 1 if this apk is malware and -1 if this apk is unkown
     * @throws Exception
     */
	public static int forest(String practiceUrl,Instances testInstances) {
		try {
            DataSource trainSource = new DataSource(practiceUrl);
            Instances trainInstances = trainSource.getDataSet();
            trainInstances.setClassIndex(trainInstances.numAttributes()-1);
            testInstances.setClassIndex(testInstances.numAttributes()-1);


            Remove rm1 = new Remove();
            rm1.setAttributeIndices("1");
            rm1.setInputFormat(trainInstances);
            Instances trainInstancesRemoved=Filter.useFilter(trainInstances, rm1);

            Remove rm2 = new Remove();
            rm2.setAttributeIndices("1");
            rm2.setInputFormat(testInstances);
            Instances testInstancesRemoved = Filter.useFilter(testInstances, rm2);


            // random train data
            long seed=12341;
            Instances trainInstancesRandomed = new Instances(trainInstancesRemoved);
            trainInstancesRandomed.randomize(new Random(seed));
            String className = "weka.classifiers.trees.RandomForest";
            String[] options = new String[2];
            options[0] = "-I";
            options[1] = "100";
            Classifier cf = (Classifier)Utils.forName(Classifier.class, className,options);

            Evaluation evaluation=new Evaluation(trainInstancesRandomed);
            Instances predict=null;

            Classifier cfs=AbstractClassifier.makeCopy(cf);
            cfs.buildClassifier(trainInstancesRandomed);
            evaluation.evaluateModel(cfs,testInstancesRemoved);

            AddClassification filter=new AddClassification();
            filter.setClassifier(cfs);
            filter.setInputFormat(testInstancesRemoved);
            filter.setOutputClassification(true);
            Filter.useFilter(trainInstancesRandomed, filter);
            Instances pred=Filter.useFilter(testInstancesRemoved, filter);
            if(predict==null) {
                predict=new Instances(pred,0);
            }
            for(int j=0;j<pred.numInstances();j++) {
                predict.add(pred.instance(j));
            }
            if (predict.numInstances() == 1) {
                String []s = predict.instance(0).toString().split(",");
                if(s[s.length-1].equals("no")) {
                    return 0;
                } else if(s[s.length-1].equals("yes")) {
                    return 1;
                } else {
                    return -1;
                }
            }
            return -1;


        } catch (Exception e) {
		    e.printStackTrace();
		    return -1;
        }

	}
	
	public void DecideTreeUse(String path,String testUrl) throws Exception {
		DataSource data=new DataSource(path);
		Instances instances=data.getDataSet();
		instances.setClassIndex(instances.numAttributes()-1);
		String[] options=new String[2];
		options[0]="-R";
		options[1]="1";
		Remove rm=new Remove();
		rm.setOptions(options);
		rm.setInputFormat(instances);
		Instances testInstances=Filter.useFilter(instances, rm);
		J48 j48=new J48();
		j48.buildClassifier(testInstances);
		Evaluation eva=new Evaluation(testInstances);
		eva.evaluateModel(j48, testInstances);
		/*System.out.println(eva.toSummaryString());*/
		
	}

	
	public static int selectLength(String a,String b){
		if(a.length()>b.length())
			return b.length();
		else
			return a.length();
	}

	
	public void featureRanker(String path) throws Exception{
		DataSource ds=new DataSource(path);



	    Instances trainIns = ds.getDataSet();

		trainIns.setClassIndex(trainIns.numAttributes()-1);



		Ranker rank = new Ranker();

		InfoGainAttributeEval eval = new InfoGainAttributeEval();


		eval.buildEvaluator(trainIns);

		/*System.out.println(rank.search(eval, trainIns));*/



		int[] attrIndex = rank.search(eval, trainIns);


		StringBuffer attrIndexInfo = new StringBuffer();

		 StringBuffer attrInfoGainInfo = new StringBuffer();

		attrIndexInfo.append("Selected attributes:");

		attrInfoGainInfo.append("Ranked attributes:/n");

		for(int i = 0; i < attrIndex.length; i ++){

		attrIndexInfo.append(attrIndex[i]);

		attrIndexInfo.append(",");


		attrInfoGainInfo.append(eval.evaluateAttribute(attrIndex[i]));

		attrInfoGainInfo.append("/t");

		attrInfoGainInfo.append((trainIns.attribute(attrIndex[i]).name()));

		attrInfoGainInfo.append("/n");



	    System.out.println(attrIndexInfo.toString());

	    System.out.println(attrInfoGainInfo.toString());
	    }
	}

    public static Instances set_Instances(Instances instances, String featurePath, boolean type){


        ArrayList<String> isMalware=new ArrayList();
        isMalware.add("no");
        isMalware.add("yes");



        List<String> lines = cn.Utils.fileRead(featurePath);

        for (String line:lines) {
            if (line.equals("")) {
                continue;
            }
            line = line.trim();
            String []s = line.split(",");
            if (s.length != 3465) {
                continue;
            }
            double[] instance = new double[instances.numAttributes()];
            int index = 0;
            int sIndex = 0;
            instance[index++] = instances.attribute(0).addStringValue(s[sIndex++]);

            // jump wrong 720
            for (int i=0;i<2743;i++) {
                if (i == 2622) {
                    sIndex += 720;
                }
                instance[index++] = Double.parseDouble(s[sIndex++]);
            }

            if(type){
                instance[instances.numAttributes()-1]=isMalware.indexOf("yes");
            } else{
                instance[instances.numAttributes()-1]=isMalware.indexOf("no");
            }

            instances.add(new DenseInstance(1.0,instance));
        }


        return instances;

    }
	
	
}
